<?xml version="1.0" encoding="UTF-8"?>

<!--
  Copyright Â© 2021 Mark Raynsford <code@io7m.com> https://www.io7m.com

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  -->

<Section xmlns="urn:com.io7m.structural:8:0"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         id="ca08def3-1e26-4007-9faf-e3eacede50bb"
         title="First-Person Camera">

  <Subsection id="0bbc4393-cb61-4d03-b1c8-c1bc23120816" title="Overview">
    <Paragraph>
      In order to aid comprehension, and to follow good software engineering practices, the usage example here will be
      developed as a set of types with well-defined interfaces. Specifically, a simple main program will initialize an
      OpenGL window with JOGL, and register some keyboard and mouse listeners to supply input to a
      <Term type="term">simulation</Term>, which in turn periodically produces new data (a <Term type="term">
      view matrix</Term>) for a <Term type="term">renderer</Term>. The <Term type="term">renderer</Term> draws
      a simple static scene using the view matrix periodically produced by a camera from the
      <Term type="package">${project.parent.name}</Term>
      package. The
      <Term type="term">simulation</Term>
      runs at a fixed time step to provide completely frame rate independent movement (see the article
      <LinkExternal target="http://gafferongames.com/game-physics/fix-your-timestep/">
        "Fix Your Timestep!"
      </LinkExternal>
      for details on why physical simulations should use fixed time steps). The <Term type="term">renderer</Term>,
      however, runs at an arbitrary frame rate. On some systems the frame rate will be exactly equal to the screen's
      vertical refresh rate, whilst on others, the rate will be thousands of times per second. The desire is to show
      that the system works equally well no matter what frame rate is used, so no attempt is made to enforce any
      particular rate. A rough graph of the data flow between components is as follows:
    </Paragraph>
    <FormalItem type="diagram" title="Example Data Flow">
      <Image source="images/example_dataflow.png">Example data flow</Image>
    </FormalItem>
    <Paragraph>
      JOGL works with an event-based model, where mouse and keyboard input causes events to be delivered to mouse and
      keyboard <Term type="term">listeners</Term>. Additionally, OpenGL rendering typically occurs via an OpenGL
      <Term type="term">listener</Term>: JOGL (or the GPU, or the operating system, whichever is responsible)
      indicates that it is time to render the scene, and the user's registered <Term type="term">listener</Term> is
      executed to actually perform the drawing. It's reasonable to assume that input handling and rendering occur on
      different threads by default, so the code here is careful to operate in a thread-safe manner.
    </Paragraph>
    <Paragraph>
      The interface exposed to JOGL by the example renderer is as follows
      [<LinkExternal target="com/io7m/jcamera/examples/jogl/ExampleRendererType.java">
      ExampleRendererType.java</LinkExternal>]:
    </Paragraph>
    <FormalItem type="examples" title="Renderer Interface">
      <Verbatim>
        <xi:include href="com/io7m/jcamera/examples/jogl/ExampleRendererType.java"
                    parse="text"/>
      </Verbatim>
    </FormalItem>
    <Paragraph>
      Little is needed in the way of explanation here. The renderer initializes the scene's resources when
      <Term type="function">init</Term> is called (such as allocating memory on the GPU for mesh data, compiling
      shaders, etc). The renderer draws the scene whenever <Term type="function">draw</Term> is called, and
      recalculates any internal resources that are dependent on the size of the window (such as
      the scene's <Term type="term">projection matrix</Term>) when <Term type="function">reshape</Term> is
      called.
    </Paragraph>
    <Paragraph>
      The actual implementation of the renderer is of little interest here. It simply draws a hundred or so static quads
      from the perspective of whatever is the current view matrix. The implementation is given in
      <LinkExternal target="com/io7m/jcamera/examples/jogl/ExampleRenderer.java">ExampleRenderer</LinkExternal>
      and will not be referenced again.
    </Paragraph>
  </Subsection>

  <Subsection id="cad2735d-4e35-42bd-bcbd-5b4f732f0b1c" title="FPS Simulation">
    <Paragraph>
      The interface exposed to JOGL by the example simulation is as follows
      [<LinkExternal target="com/io7m/jcamera/examples/jogl/ExampleFPSStyleSimulationType.java">
      ExampleFPSStyleSimulationType.java</LinkExternal>]:
    </Paragraph>
    <FormalItem type="examples" title="Simulation Interface">
      <Verbatim>
        <xi:include href="com/io7m/jcamera/examples/jogl/ExampleFPSStyleSimulationType.java"
                    parse="text"/>
      </Verbatim>
    </FormalItem>
    <Paragraph>
      Again, little is needed in the way of explanation. The simulation provides a camera that can be enabled and
      disabled. If the camera is disabled, a simple fixed camera is used rather than having the camera be driven by
      keyboard and mouse input.
    </Paragraph>
    <Paragraph id="e0e10f7b-bf2c-4f03-99d2-fea41718e977">
      The simulation needs a way to periodically warp the mouse cursor to the center of the screen if the movable camera
      is enabled, so the renderer exposes the following interface to the simulation
      [<LinkExternal target="com/io7m/jcamera/examples/jogl/ExampleRendererControllerType.java">
      ExampleRendererControllerType.java</LinkExternal>]:
    </Paragraph>
    <FormalItem type="examples" title="Renderer Control Interface">
      <Verbatim>
        <xi:include href="com/io7m/jcamera/examples/jogl/ExampleRendererControllerType.java"
                    parse="text"/>
      </Verbatim>
    </FormalItem>
    <Paragraph>
      The actual implementation of the simulation is as follows
      [<LinkExternal target="com/io7m/jcamera/examples/jogl/ExampleFPSStyleSimulation.java">
      ExampleFPSStyleSimulation.java</LinkExternal>]. First:
    </Paragraph>
    <FormalItem type="examples" title="Camera Declarations and Storage">
      <Verbatim>
        <xi:include href="example-fps-sim-0.txt"
                    parse="text"/>
      </Verbatim>
    </FormalItem>
    <Paragraph>
      Then, an <Link target="3af181c8-f7e3-401c-aa92-adc97b68423b">integrator</Link> is created to drive the camera, and the
      integration period required for a fixed time step of
      <Term type="expression">60</Term>
      frames per second is calculated:
    </Paragraph>
    <FormalItem type="examples" title="Integrator">
      <Verbatim>
        <xi:include href="example-fps-sim-1.txt"
                    parse="text"/>
      </Verbatim>
    </FormalItem>
    <Paragraph>
      Finally, to give the camera somewhat more snappy and abrupt behaviour than the default settings, some new
      acceleration and drag values are configured for the camera:
    </Paragraph>
    <FormalItem type="examples" title="Acceleration and Drag">
      <Verbatim>
        <xi:include href="example-fps-sim-2.txt"
                    parse="text"/>
      </Verbatim>
    </FormalItem>
    <Paragraph>
      The <Term type="function">integrate</Term> function is executed at a rate of <Term type="expression">
      60
    </Term> times per second, and produces a new snapshot each time, which is passed to the renderer. The immutable
      nature of the snapshot means that it can be safely shared across threads without any need for locks or other
      synchronization. If the camera is actually enabled, the simulation also instructs the renderer to warp the mouse
      cursor back to the center of the screen. The rest of the functions complete the interface.
    </Paragraph>
    <FormalItem type="examples" title="Integrate">
      <Verbatim>
        <xi:include href="example-fps-sim-3.txt"
                    parse="text"/>
      </Verbatim>
    </FormalItem>
  </Subsection>

  <Subsection id="8178d84c-faf4-4109-9c12-2aabb0f1714f" title="Input">
    <Paragraph>
      It's now necessary to supply the simulation with input.
    </Paragraph>
    <Paragraph>
      A <Term type="type">KeyListener</Term> is defined. Every time the user presses or releases a key, the
      simulation camera's input is notified accordingly.
    </Paragraph>
    <Paragraph>
      There is one main issue covered here: If the user has keyboard auto-repeat enabled by their operating system,
      holding a key will result in an endless stream of "key pressed" and "key released" events. The code here is only
      interested in receiving the first "key pressed" and last "key released" event for each key, and JOGL's NEWT system
      marks each event as having been produced by auto-repeat (or not). Therefore, the auto-repeat flag is checked for
      each event, and the event is discarded if the flag is set.
    </Paragraph>
    <Paragraph>
      Additionally, a few extra definitions allow for showing/hiding the mouse cursor, and switching between windowed
      and full-screen mode. JOGL requires that the <Term type="function">setFullscreen</Term> function be called
      on a background thread, rather than the thread handling input and/or rendering for the current window.
    </Paragraph>
    <FormalItem type="examples" title="Main (KeyListener)">
      <Verbatim>
        <xi:include href="com/io7m/jcamera/examples/jogl/ExampleFPSStyleKeyListener.java"
                    parse="text"/>
      </Verbatim>
    </FormalItem>
    <Paragraph>
      A <Term type="type">MouseAdapter</Term> is defined. Every time the user moves the mouse, the rotation
      coefficients are calculated and sent to the simulation camera's input:
    </Paragraph>
    <FormalItem type="examples" title="Main (MouseAdapter)">
      <Verbatim>
        <xi:include href="com/io7m/jcamera/examples/jogl/ExampleFPSStyleMouseAdapter.java"
                    parse="text"/>
      </Verbatim>
    </FormalItem>
  </Subsection>

  <Subsection id="d949dd61-deec-4b5d-bf5a-3674d6d87640" title="Rendering/Interpolation">
    <Paragraph>
      A <Term type="type">GLEventListener</Term> is added to the window. The listener will tell the renderer to
      draw the scene every time the OpenGL implementation requires a new frame.
    </Paragraph>
    <Paragraph>
      The <Term type="function">display</Term> method linearly interpolates between the most recently received
      camera snapshots in order to provide smooth animation independent of the simulation and/or frame rate.
    </Paragraph>
    <FormalItem type="examples" title="Main (GLEventListener)">
      <Verbatim>
        <xi:include href="com/io7m/jcamera/examples/jogl/ExampleFPSStyleGLListener.java"
                    parse="text"/>
      </Verbatim>
    </FormalItem>
  </Subsection>

  <Subsection id="0197c711-74c5-4d79-9890-e239b52e772f" title="Main">
    <Paragraph>
      All that remains is to have JOGL tell the renderer when to render, and to supply the simulation with input in
      order to move and orient the camera according to mouse and keyboard input. The main program constructs a new
      renderer:
    </Paragraph>
    <FormalItem type="examples" title="Main (Renderer)">
      <Verbatim>
        <xi:include href="example-fps-main-0.txt"
                    parse="text"/>
      </Verbatim>
    </FormalItem>
    <Paragraph>
      Then, a new simulation is constructed, and is passed a reference to the renderer (the type of the simulation
      constructor is declared such that it only sees a 
      <Link target="e0e10f7b-bf2c-4f03-99d2-fea41718e977">small subset</Link> of the interface exposed by the renderer).
      The simulation camera's input is also retrieved:
    </Paragraph>
    <FormalItem type="examples" title="Main (Simulation)">
      <Verbatim>
        <xi:include href="example-fps-main-1.txt"
                    parse="text"/>
      </Verbatim>
    </FormalItem>
    <Paragraph>
      Some storage is allocated, and a
      <Link target="2febf7e6-6321-4a53-908e-76311253daf8">mouse region</Link>
      is created to map mouse movements to rotational coefficients:
    </Paragraph>
    <FormalItem type="examples" title="Main (Mouse region and coefficients)">
      <Verbatim>
        <xi:include href="example-fps-main-2.txt"
                    parse="text"/>
      </Verbatim>
    </FormalItem>
    <Paragraph>
      An OpenGL window is created, an
      <Term type="type">Animator</Term>
      is constructed that will tell the window to refresh frequently, and the previously defined listeners are attached
      to the window.
    </Paragraph>
    <FormalItem type="examples" title="Main (Window and animator)">
      <Verbatim>
        <xi:include href="example-fps-main-3.txt"
                    parse="text"/>
      </Verbatim>
    </FormalItem>
    <FormalItem type="diagram" title="Example Screenshot">
      <Image source="images/example.png">Example screenshot</Image>
    </FormalItem>
  </Subsection>

</Section>
